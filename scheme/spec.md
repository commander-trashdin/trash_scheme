# Спецификация языка

## Примитивные типы
Простейшее выражение языка - объект примитивного типа: целое число, булево значение, _символ_ (имя встроенной или пользовательской функции, переменной)
```
    42 => 42
    -7 => -7
    #t => #t
    #f => #f
    and => #<Symbol and>
    quote => #<Symbol quote>
    + => #<Function +>
```
`#t`, `#f` - это булевы значения.

`and`, `quote`, `+` - символы, встроенные функции.

У _символа_ без определения результатом выполнения будет ошибка:
```
    hello => Execution error: unbound symbol "hello"
```
Ошибка приведена только для примера, конкретное поведение не специфицируется.

В _символах_ могут встретиться только ASCII-символы. Пользовательские идентификаторы могут состоять только из латинских букв и цифр. Регистр значим. `plus` и `PLUS` - должны быть разными переменными.

## Применение функций к примитивным типам

Арифметические выражения с числами выглядит так:
```
    (+ 1 2) => 3
    (* 2 3 4) => 24
    (/ 10 2) => 5
    (/ 1 2) => 0
```
Для вызова функции нужно составить _список_ вида `(<символ функции> [<аргументы функции>])`.
_Cписок_ - пока стоит понимать как последовательность элементов, строже он будет описан далее.

### Функции для работы с целыми числами

1. `+`, `-`, `*`, `/`
2. `=`, `>`, `<`, `>=`, `<=`
3. `min`, `max`, `abs`
Можно применять только к целым числам.

### Логические функции

1. `not`

В логическом контексте, ложным является только значение `#f`, все
остальные значения (в том числе `0` и пустой список `'()`) являются
истинными.

### Предикаты
Предикат - функция, проверяющая некоторое предположение. Возвращает булево значение.
По соглашению, названия предикатов всегда заканчиваются `?`

Встроенные предикаты.
1. `null?`
2. `pair?`
3. `number?`
4. `boolean?`
5. `symbol?`
6. `list?`
7. `eq?`, `equal?`
8. `integer-equal?`


## Списки и пары

Единственный композитный тип - это пара. Записывается как 
`'(1 . 2)`. Списки строятся из пар.

`'(1 2 3)` то же самое, что и `'(1 . (2 . (3 . ())))`.

Пустой список `'()` - это синоним `nullptr`.

[Более подробно](https://www.gnu.org/software/emacs/manual/html_node/elisp/Dotted-Pair-Notation.html)


Чтобы подавить выполнение выражения, нужно использовать специальную форму quote
```
    (quote (+ 1 2)) => (+ 1 2)
```
Интерпретатор не выполняет выражения, заэкранированные этой формой.
Для quote есть короткая запись
```
    '(+ 1 2) => (+ 1 2)
```
## Допустимые токены

1. `(` - открывающаяся скобка.
2. `)` - закрывающаяся скобка.
3. `3`, `-6` - число.
4. `'` - одинарная кавычка. Используется как сокращенная запись для
   особой формы `quote`.
5. `.` - точка. Используется для записи пары `(1 . 2)` и списка `(1 2 . 3)`.
6. `foo-bar` - представляет имя переменной в программе. Имя не может
   начинаться с `+` или `-`, за исключением особых случаев `+` и
   `-`. *`+1` - это число, а `+` - это идентификатор `+`*

## Правила выполнения
   - `2 => 2` - числа преобразуются сами в себя.
   - `a => 4` - символы преобразуются в значение переменной.
   - `(+ a 3) => (#<plus-function> 2 3) => #<plus-function>(2, 3) => 5` - списки вычисляют в 2 этапа.
    1. Все элементы списка вычисляются рекурсивно.
    2. Значение первого элемента интерпретируется как функция и
       применяется к оставщимся элементам списка.
   - `(set! x 1)` - Если первым элементом списка является специальная
     форма, то вычисление происходит по специальным правилам
     вычисления этой формы. Например форма `set!` принимает `x` первым
     аргументом просто как имя. По правилам вычисления функций `x`
     должен был бы быть преобразован в значение переменной `x`

## Список особых форм

### `if`

Работает как if :D Возможны 2 формы записи.

* `(if condition true-branch)`
* `(if condition true-branch false-branch)`
    
Сначала вычисляет `condition` и проверяет значение на истинность
(с.м. определение истинности). Затем вычисляет либо `true-branch`,
либо `false-branch` и возвращает как результат всего `if`-а.

### `quote`

Возможны 2 формы записи, полная и короткая.

* `(quote (1 2 3))`
* `'(1 2 3)`
  
Возвращает единственных аргумент AST, не вычисляя его.

### Лямбда выражение.
 
* `(lambda (x) (+ 1 x))`
* `(lambda (x y) (* y x))`
* `(lambda () 1)`
  
Создаёт новую функцию. Сначала перечисляется список аргументов
функции, затем её тело. Тело может состоять из нескольких выражений,
в этом случае они вычисляются по порядку а результат последнего
выражения становится результатом функции.

### `and`, `or` - логические выражения с _short-circuit evaluation_.

* `(and)`, `(and (= 2 2) (> 2 1))`
* `(or #f)`, `(or #f (launch-nukes))`
  
Работают похоже на `&&` и `||` в C++. Вычисляют аргументы по
порядку, останавливаясь когда значение всего выражения уже не может поменяться.

### `define`

Объявляет новую переменную или перезаписывает переменную новым значением.

* `(define x '(1 2))` - создаёт переменную `x` со значением `(1 2)`
* `(define (inc x) (+ x 1))` - создаёт новую функцию `inc`.

Запись `(define (fn-name <args>) <body>)` эквивалентна
`(define fn-name (lambda (<args>) <body>))`

### `set!`

`set!` изменяет значение уже существующей переменной. Если переменной
небыло, `set!` завершается ошибкой.

* `(set! x 1)`

## Список встроенных функций

### Предикаты

1. `null?`
2. `pair?`
3. `number?`
4. `boolean?`
5. `symbol?`
6. `list?`
7. `eq?`, `equal?`
8. `integer-equal?`

### Логические функции

1. `not`

### Функции для работы с целыми числами

1. `+`, `-`, `*`, `/`
2. `=`, `>`, `<`, `>=`, `<=`
3. `min`, `max`, `abs`
 
### Функции для работы со списками

1. `cons`
2. `car`, `cdr`
3. `set-car!`, `set-cdr!`
4. `list`
5. `list-ref`, `list-tail`
